// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.3
// source: multipass.proto

package client

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RpcClient is the client API for Rpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RpcClient interface {
	Launch(ctx context.Context, opts ...grpc.CallOption) (Rpc_LaunchClient, error)
	List(ctx context.Context, opts ...grpc.CallOption) (Rpc_ListClient, error)
	Networks(ctx context.Context, opts ...grpc.CallOption) (Rpc_NetworksClient, error)
	Start(ctx context.Context, opts ...grpc.CallOption) (Rpc_StartClient, error)
	Delet(ctx context.Context, opts ...grpc.CallOption) (Rpc_DeletClient, error)
	Version(ctx context.Context, opts ...grpc.CallOption) (Rpc_VersionClient, error)
	Authenticate(ctx context.Context, opts ...grpc.CallOption) (Rpc_AuthenticateClient, error)
}

type rpcClient struct {
	cc grpc.ClientConnInterface
}

func NewRpcClient(cc grpc.ClientConnInterface) RpcClient {
	return &rpcClient{cc}
}

func (c *rpcClient) Launch(ctx context.Context, opts ...grpc.CallOption) (Rpc_LaunchClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rpc_ServiceDesc.Streams[0], "/multipass.Rpc/launch", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcLaunchClient{stream}
	return x, nil
}

type Rpc_LaunchClient interface {
	Send(*LaunchRequest) error
	Recv() (*LaunchReply, error)
	grpc.ClientStream
}

type rpcLaunchClient struct {
	grpc.ClientStream
}

func (x *rpcLaunchClient) Send(m *LaunchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rpcLaunchClient) Recv() (*LaunchReply, error) {
	m := new(LaunchReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcClient) List(ctx context.Context, opts ...grpc.CallOption) (Rpc_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rpc_ServiceDesc.Streams[1], "/multipass.Rpc/list", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcListClient{stream}
	return x, nil
}

type Rpc_ListClient interface {
	Send(*ListRequest) error
	Recv() (*ListReply, error)
	grpc.ClientStream
}

type rpcListClient struct {
	grpc.ClientStream
}

func (x *rpcListClient) Send(m *ListRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rpcListClient) Recv() (*ListReply, error) {
	m := new(ListReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcClient) Networks(ctx context.Context, opts ...grpc.CallOption) (Rpc_NetworksClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rpc_ServiceDesc.Streams[2], "/multipass.Rpc/networks", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcNetworksClient{stream}
	return x, nil
}

type Rpc_NetworksClient interface {
	Send(*NetworksRequest) error
	Recv() (*NetworksReply, error)
	grpc.ClientStream
}

type rpcNetworksClient struct {
	grpc.ClientStream
}

func (x *rpcNetworksClient) Send(m *NetworksRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rpcNetworksClient) Recv() (*NetworksReply, error) {
	m := new(NetworksReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcClient) Start(ctx context.Context, opts ...grpc.CallOption) (Rpc_StartClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rpc_ServiceDesc.Streams[3], "/multipass.Rpc/start", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcStartClient{stream}
	return x, nil
}

type Rpc_StartClient interface {
	Send(*StartRequest) error
	Recv() (*StartReply, error)
	grpc.ClientStream
}

type rpcStartClient struct {
	grpc.ClientStream
}

func (x *rpcStartClient) Send(m *StartRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rpcStartClient) Recv() (*StartReply, error) {
	m := new(StartReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcClient) Delet(ctx context.Context, opts ...grpc.CallOption) (Rpc_DeletClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rpc_ServiceDesc.Streams[4], "/multipass.Rpc/delet", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcDeletClient{stream}
	return x, nil
}

type Rpc_DeletClient interface {
	Send(*DeleteRequest) error
	Recv() (*DeleteReply, error)
	grpc.ClientStream
}

type rpcDeletClient struct {
	grpc.ClientStream
}

func (x *rpcDeletClient) Send(m *DeleteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rpcDeletClient) Recv() (*DeleteReply, error) {
	m := new(DeleteReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcClient) Version(ctx context.Context, opts ...grpc.CallOption) (Rpc_VersionClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rpc_ServiceDesc.Streams[5], "/multipass.Rpc/version", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcVersionClient{stream}
	return x, nil
}

type Rpc_VersionClient interface {
	Send(*VersionRequest) error
	Recv() (*VersionReply, error)
	grpc.ClientStream
}

type rpcVersionClient struct {
	grpc.ClientStream
}

func (x *rpcVersionClient) Send(m *VersionRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rpcVersionClient) Recv() (*VersionReply, error) {
	m := new(VersionReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rpcClient) Authenticate(ctx context.Context, opts ...grpc.CallOption) (Rpc_AuthenticateClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rpc_ServiceDesc.Streams[6], "/multipass.Rpc/authenticate", opts...)
	if err != nil {
		return nil, err
	}
	x := &rpcAuthenticateClient{stream}
	return x, nil
}

type Rpc_AuthenticateClient interface {
	Send(*AuthenticateRequest) error
	Recv() (*AuthenticateReply, error)
	grpc.ClientStream
}

type rpcAuthenticateClient struct {
	grpc.ClientStream
}

func (x *rpcAuthenticateClient) Send(m *AuthenticateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rpcAuthenticateClient) Recv() (*AuthenticateReply, error) {
	m := new(AuthenticateReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RpcServer is the server API for Rpc service.
// All implementations must embed UnimplementedRpcServer
// for forward compatibility
type RpcServer interface {
	Launch(Rpc_LaunchServer) error
	List(Rpc_ListServer) error
	Networks(Rpc_NetworksServer) error
	Start(Rpc_StartServer) error
	Delet(Rpc_DeletServer) error
	Version(Rpc_VersionServer) error
	Authenticate(Rpc_AuthenticateServer) error
	mustEmbedUnimplementedRpcServer()
}

// UnimplementedRpcServer must be embedded to have forward compatible implementations.
type UnimplementedRpcServer struct {
}

func (UnimplementedRpcServer) Launch(Rpc_LaunchServer) error {
	return status.Errorf(codes.Unimplemented, "method Launch not implemented")
}
func (UnimplementedRpcServer) List(Rpc_ListServer) error {
	return status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRpcServer) Networks(Rpc_NetworksServer) error {
	return status.Errorf(codes.Unimplemented, "method Networks not implemented")
}
func (UnimplementedRpcServer) Start(Rpc_StartServer) error {
	return status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedRpcServer) Delet(Rpc_DeletServer) error {
	return status.Errorf(codes.Unimplemented, "method Delet not implemented")
}
func (UnimplementedRpcServer) Version(Rpc_VersionServer) error {
	return status.Errorf(codes.Unimplemented, "method Version not implemented")
}
func (UnimplementedRpcServer) Authenticate(Rpc_AuthenticateServer) error {
	return status.Errorf(codes.Unimplemented, "method Authenticate not implemented")
}
func (UnimplementedRpcServer) mustEmbedUnimplementedRpcServer() {}

// UnsafeRpcServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RpcServer will
// result in compilation errors.
type UnsafeRpcServer interface {
	mustEmbedUnimplementedRpcServer()
}

func RegisterRpcServer(s grpc.ServiceRegistrar, srv RpcServer) {
	s.RegisterService(&Rpc_ServiceDesc, srv)
}

func _Rpc_Launch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RpcServer).Launch(&rpcLaunchServer{stream})
}

type Rpc_LaunchServer interface {
	Send(*LaunchReply) error
	Recv() (*LaunchRequest, error)
	grpc.ServerStream
}

type rpcLaunchServer struct {
	grpc.ServerStream
}

func (x *rpcLaunchServer) Send(m *LaunchReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rpcLaunchServer) Recv() (*LaunchRequest, error) {
	m := new(LaunchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Rpc_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RpcServer).List(&rpcListServer{stream})
}

type Rpc_ListServer interface {
	Send(*ListReply) error
	Recv() (*ListRequest, error)
	grpc.ServerStream
}

type rpcListServer struct {
	grpc.ServerStream
}

func (x *rpcListServer) Send(m *ListReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rpcListServer) Recv() (*ListRequest, error) {
	m := new(ListRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Rpc_Networks_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RpcServer).Networks(&rpcNetworksServer{stream})
}

type Rpc_NetworksServer interface {
	Send(*NetworksReply) error
	Recv() (*NetworksRequest, error)
	grpc.ServerStream
}

type rpcNetworksServer struct {
	grpc.ServerStream
}

func (x *rpcNetworksServer) Send(m *NetworksReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rpcNetworksServer) Recv() (*NetworksRequest, error) {
	m := new(NetworksRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Rpc_Start_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RpcServer).Start(&rpcStartServer{stream})
}

type Rpc_StartServer interface {
	Send(*StartReply) error
	Recv() (*StartRequest, error)
	grpc.ServerStream
}

type rpcStartServer struct {
	grpc.ServerStream
}

func (x *rpcStartServer) Send(m *StartReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rpcStartServer) Recv() (*StartRequest, error) {
	m := new(StartRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Rpc_Delet_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RpcServer).Delet(&rpcDeletServer{stream})
}

type Rpc_DeletServer interface {
	Send(*DeleteReply) error
	Recv() (*DeleteRequest, error)
	grpc.ServerStream
}

type rpcDeletServer struct {
	grpc.ServerStream
}

func (x *rpcDeletServer) Send(m *DeleteReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rpcDeletServer) Recv() (*DeleteRequest, error) {
	m := new(DeleteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Rpc_Version_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RpcServer).Version(&rpcVersionServer{stream})
}

type Rpc_VersionServer interface {
	Send(*VersionReply) error
	Recv() (*VersionRequest, error)
	grpc.ServerStream
}

type rpcVersionServer struct {
	grpc.ServerStream
}

func (x *rpcVersionServer) Send(m *VersionReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rpcVersionServer) Recv() (*VersionRequest, error) {
	m := new(VersionRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Rpc_Authenticate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RpcServer).Authenticate(&rpcAuthenticateServer{stream})
}

type Rpc_AuthenticateServer interface {
	Send(*AuthenticateReply) error
	Recv() (*AuthenticateRequest, error)
	grpc.ServerStream
}

type rpcAuthenticateServer struct {
	grpc.ServerStream
}

func (x *rpcAuthenticateServer) Send(m *AuthenticateReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rpcAuthenticateServer) Recv() (*AuthenticateRequest, error) {
	m := new(AuthenticateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Rpc_ServiceDesc is the grpc.ServiceDesc for Rpc service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rpc_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "multipass.Rpc",
	HandlerType: (*RpcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "launch",
			Handler:       _Rpc_Launch_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "list",
			Handler:       _Rpc_List_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "networks",
			Handler:       _Rpc_Networks_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "start",
			Handler:       _Rpc_Start_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "delet",
			Handler:       _Rpc_Delet_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "version",
			Handler:       _Rpc_Version_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "authenticate",
			Handler:       _Rpc_Authenticate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "multipass.proto",
}
